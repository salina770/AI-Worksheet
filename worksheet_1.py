# -*- coding: utf-8 -*-
"""Worksheet 1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fEhkxxe6yh8UbuVCYiZeTbzsE2PBX8fj

Submitted By: Salina Gurung

Basic Vector and Matrix Operation with Numpy.

Problem 1 : Array Creation:
"""

import numpy as np
import time

# 1) Empty 2x2 array
empty_2x2 = np.empty((2, 2))
print("1) Empty 2x2:\n", empty_2x2)

# 2) All ones array 4x2
ones_4x2 = np.ones((4, 2))
print("\n2) Ones 4x2:\n", ones_4x2)

# 3) Array filled with a value
filled = np.full((3, 4), 7)  # example shape 3x4, fill with 7
print("\n3) Filled array (3x4) with 7:\n", filled)

# 4) Zeros array same shape as a given array
given = np.array([[1.5, 2.5], [3.5, 4.5]])
zeros_like_given = np.zeros_like(given)
print("\n4) Zeros like given:\n", zeros_like_given)

# 5) Ones array same shape as a given array
ones_like_given = np.ones_like(given)
print("\n5) Ones like given:\n", ones_like_given)

# 6) Convert list to numpy array
new_list = [1, 2, 3, 4]
converted = np.array(new_list)
print("\n6) Converted list to np array:\n", converted)

"""Problem 2 : Array Manipulation: Numerical Ranges and Array indexing:"""

# 1) Array from 10 to 49
arr_10_49 = np.arange(10, 50)
print("1) Array 10–49:\n", arr_10_49)

# 2) 3x3 matrix 0 to 8
matrix_3x3 = np.arange(9).reshape(3, 3)
print("\n2) 3x3 matrix 0–8:\n", matrix_3x3)

# 3) Identity matrix 3x3
I3 = np.eye(3)
print("\n3) Identity 3x3:\n", I3)

# 4) Random array of size 30 + mean
r30 = np.random.random(30)
print("\n4) Random 30 array:\n", r30)
print("Mean:", r30.mean())

# 5) 10x10 random array min, max
r10 = np.random.random((10, 10))
print("\n5) Random 10x10:\n", r10)
print("Min:", r10.min(), "Max:", r10.max())

# 6) Zero array size 10, replace 5th element with 1
z10 = np.zeros(10)
z10[4] = 1
print("\n6) Replace 5th with 1:\n", z10)

# 7) Reverse an array
arr = np.array([1, 2, 0, 0, 4, 0])
rev = arr[::-1]
print("\n7) Reversed array:\n", rev)

# 8) Border 1s, inside 0s (example 5x5)
border = np.ones((5, 5))
border[1:-1, 1:-1] = 0
print("\n8) Border ones, inside zeros:\n", border)

# 9) 8x8 checkerboard
chk = np.zeros((8, 8), dtype=int)
chk[1::2, ::2] = 1
chk[::2, 1::2] = 1
print("\n9) Checkerboard pattern:\n", chk)

"""Problem 3 : Array Operations:"""

x = np.array([[1, 2],
              [3, 5]])

y = np.array([[5, 6],
              [7, 8]])

v = np.array([9, 10])
w = np.array([11, 12])

# 1) Add
print("1) x + y:\n", x + y)

# 2) Subtract
print("\n2) x - y:\n", x - y)

# 3) Multiply with integers
print("\n3) x * 3:\n", x * 3)
print("y * 2:\n", y * 2)

# 4) Square elements
print("\n4) x squared:\n", x ** 2)

# 5) Dot products
print("\n5a) v·w =", np.dot(v, w))
print("5b) x·v:\n", x.dot(v))
print("5c) x·y:\n", x.dot(y))

# 6) Concatenate
xy_concat = np.concatenate((x, y), axis=0)
print("\n6a) x & y row concat:\n", xy_concat)

vw_concat = np.concatenate((v.reshape(-1, 1), w.reshape(-1, 1)), axis=1)
print("\n6b) v & w column concat:\n", vw_concat)

# 7) Try concatenating x and v
try:
    bad = np.concatenate((x, v))
except Exception as e:
    print("\n7) Error concatenating x and v:\n", e)
    print("Reason: x is 2D with shape", x.shape,
          "but v is 1D with shape", v.shape)

"""Problem 4: Matrix Operations:"""

A = np.array([[3, 4],
              [7, 8]])

B = np.array([[5, 3],
              [2, 1]])

# 1) A * A^-1 = I
A_inv = np.linalg.inv(A)
print("1) A @ A_inv:\n", A @ A_inv)

# 2) AB != BA
print("\n2) AB:\n", A @ B)
print("BA:\n", B @ A)
print("Equal?", np.allclose(A @ B, B @ A))

# 3) (AB)^T = B^T A^T
left = (A @ B).T
right = B.T @ A.T
print("\n3) (AB)^T:\n", left)
print("B^T A^T:\n", right)
print("Equal?", np.allclose(left, right))

"""Linear equation using Inverse Methods"""

A_sys = np.array([
    [ 2, -3,  1],
    [ 1, -1,  2],
    [ 3,  1, -1]
])

B_sys = np.array([-1, -3, 9])

# Using inverse
X_inv = np.linalg.inv(A_sys) @ B_sys
print("Solution using inverse:\n", X_inv)

# Using solve()
X_solve = np.linalg.solve(A_sys, B_sys)
print("\nSolution using np.linalg.solve:\n", X_solve)

"""Experiment: How Fast is Numpy?

Python Lists Vs NumPy Speed
"""

N = 1_000_000

# Prepare lists and numpy arrays
list1 = list(range(N))
list2 = list(range(N))

arr1 = np.array(list1)
arr2 = np.array(list2)

# 1) Element-wise addition
start = time.time()
list_add = [list1[i] + list2[i] for i in range(N)]
print("List addition time:", time.time() - start)

start = time.time()
np_add = arr1 + arr2
print("NumPy addition time:", time.time() - start)

# 2) Element-wise multiplication
start = time.time()
list_mul = [list1[i] * list2[i] for i in range(N)]
print("\nList multiplication time:", time.time() - start)

start = time.time()
np_mul = arr1 * arr2
print("NumPy multiplication time:", time.time() - start)

# 3) Dot product
start = time.time()
list_dot = sum(list1[i] * list2[i] for i in range(N))
print("\nList dot product time:", time.time() - start)

start = time.time()
np_dot = np.dot(arr1, arr2)
print("NumPy dot product time:", time.time() - start)

"""Matrix Multiplication Test (1000*1000)"""

size = 1000

# Python list matrices
M1_list = [[1]*size for _ in range(size)]
M2_list = [[1]*size for _ in range(size)]

# NumPy matrices
M1_np = np.ones((size, size))
M2_np = np.ones((size, size))

# Python list matrix multiplication
start = time.time()
M_res_list = [[sum(M1_list[i][k] * M2_list[k][j] for k in range(size))
               for j in range(size)]
              for i in range(size)]
print("List matrix multiplication time:", time.time() - start)

# NumPy matrix multiplication
start = time.time()
M_res_np = M1_np @ M2_np
print("NumPy matrix multiplication time:", time.time() - start)