# -*- coding: utf-8 -*-
"""Worksheet

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eiI5F5VU8bloEFAC0iAXa45_dfO-NuSX

Submitted By: Salina Gurung

Warming up Exercise:

Task 1
"""

time_data = [
    (3.5, 2.0, 7.0), (5.0, 1.5, 6.5), (2.5, 3.0, 8.0),
    (4.0, 2.0, 6.0), (1.5, 4.5, 9.0), (3.0, 2.5, 7.5),
    (5.5, 1.0, 6.0), (2.0, 3.5, 8.5), (4.5, 2.0, 7.0),
    (3.0, 3.0, 7.5), (6.0, 1.5, 6.0), (2.5, 4.0, 8.0),
    (4.0, 2.5, 7.0), (5.0, 2.0, 6.5), (3.5, 2.5, 7.0)
]


low = []
moderate = []
high = []


for study, entertainment, sleep in time_data:
    if study < 3:
        low.append(study)
    elif 3 <= study <= 5:
        moderate.append(study)
    else:
        high.append(study)


print("Low study hours:", low)
print("Moderate study hours:", moderate)
print("High study hours:", high)

Task 2

print("Days with low study time:", len(low))
print("Days with moderate study time:", len(moderate))
print("Days with high study time:", len(high))

"""Task 3"""

study_minutes = []

for day in time_data:
    study_hours = day[0]
    study_minutes.append(study_hours * 60)

print("Study time in minutes:", study_minutes)

"""Task 4"""

study_hours_list = []
entertainment_hours_list = []
sleep_hours_list = []

for study, entertainment, sleep in time_data:
    study_hours_list.append(study)
    entertainment_hours_list.append(entertainment)
    sleep_hours_list.append(sleep)

avg_study = sum(study_hours_list) / len(study_hours_list)
avg_entertainment = sum(entertainment_hours_list) / len(entertainment_hours_list)
avg_sleep = sum(sleep_hours_list) / len(sleep_hours_list)

print("Average study hours:", avg_study)
print("Average entertainment hours:", avg_entertainment)
print("Average sleep hours:", avg_sleep)

"""Task 5"""

import matplotlib.pyplot as plt

plt.scatter(study_hours_list, sleep_hours_list)

plt.xlabel("Study Hours")
plt.ylabel("Sleep Hours")
plt.title("Study vs Sleep Pattern")
plt.grid(True)

plt.show()

"""Recursion:

Task 1
"""

def sum_nested_list(nested_list):
    """
    Recursively sums all numbers inside a nested list.
    """
    total = 0
    for element in nested_list:
        if isinstance(element, list):
            total += sum_nested_list(element)
        else:
            total += element
    return total


# Test
nested_list = [1, [2, [3, 4], 5], 6, [7, 8]]
print("Sum:", sum_nested_list(nested_list))

"""Task 2"""

def generate_permutations(s):
    """
    Recursively generates all unique permutations of string s.
    """
    # Base case: single char or empty string
    if len(s) <= 1:
        return [s]

    permutations = []
    used = set()  # to avoid duplicates

    for i in range(len(s)):
        char = s[i]
        if char in used:
            continue
        used.add(char)

        remaining = s[:i] + s[i+1:]

        for perm in generate_permutations(remaining):
            permutations.append(char + perm)

    return permutations


# Tests
print(generate_permutations("abc"))
print(generate_permutations("aab"))

"""Task 3"""

def calculate_directory_size(directory):
    """
    Recursively calculates total size of a directory represented as nested dictionaries.
    """
    total_size = 0

    for key, value in directory.items():
        if isinstance(value, dict):
            total_size += calculate_directory_size(value)
        else:
            total_size += value

    return total_size


# Test
directory_structure = {
    "file1.txt": 200,
    "file2.txt": 300,
    "subdir1": {
        "file3.txt": 400,
        "file4.txt": 100
    },
    "subdir2": {
        "subsubdir1": {
            "file5.txt": 250
        },
        "file6.txt": 150
    }
}

print("Total directory size (KB):", calculate_directory_size(directory_structure))

"""Dynamic Programming:

Task 1
"""

def min_coins(coins, amount):
    """
    Uses DP (tabulation) to find minimum number of coins to make 'amount'.
    Returns -1 if impossible.
    """
    dp = [float("inf")] * (amount + 1)
    dp[0] = 0  # 0 coins needed to make amount 0

    for coin in coins:
        for a in range(coin, amount + 1):
            dp[a] = min(dp[a], dp[a - coin] + 1)

    return dp[amount] if dp[amount] != float("inf") else -1


# Test
print(min_coins([1, 2, 5], 11))  # expected 3

"""Task 2"""

def longest_common_subsequence(s1, s2):
    """
    Returns length of longest common subsequence between s1 and s2.
    """
    n, m = len(s1), len(s2)

    dp = [[0]*(m+1) for _ in range(n+1)]

    for i in range(1, n+1):
        for j in range(1, m+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[n][m]


# Test
print(longest_common_subsequence("abcde", "ace"))  # expected 3

"""Task 3"""

def knapsack(weights, values, capacity):
    """
    Returns maximum value that can fit into knapsack of given capacity.
    Uses DP (tabulation).
    """
    n = len(weights)
    dp = [[0]*(capacity+1) for _ in range(n+1)]

    for i in range(1, n+1):
        for cap in range(capacity+1):
            if weights[i-1] <= cap:
                dp[i][cap] = max(
                    dp[i-1][cap],                          # skip item
                    dp[i-1][cap - weights[i-1]] + values[i-1]  # take item
                )
            else:
                dp[i][cap] = dp[i-1][cap]

    return dp[n][capacity]


# Test
weights = [1, 3, 4, 5]
values = [1, 4, 5, 7]
capacity = 7

print(knapsack(weights, values, capacity))  # expected 9